<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modem Status</title>

    <!-- Link to external CSS file -->
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">

    <!-- Leaflet for map -->
    <link rel="stylesheet" href="{{ url_for('static', filename='leaflet.css') }}">
    <script src="{{ url_for('static', filename='leaflet.js') }}"></script>

    <!-- jQuery and DataTables JS for table tab-->
    <script src="{{ url_for('static', filename='jquery-3.7.1.min.js') }}"></script>
    <script src="{{ url_for('static', filename='jquery.dataTables.min.js') }}"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='jquery.dataTables.min.css') }}">

    <!-- Style for buttons-->
    <link rel="stylesheet" href="{{ url_for('static', filename='all.min.css') }}">
    
    <!-- Icon-->
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
    
    <!-- Leaflet.draw for Trail-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>





</head>
<body>

    <!-- Flash messages -->
    {% with messages = get_flashed_messages() %}
    {% if messages %}
        <ul class="flash-messages">
        {% for message in messages %}
            <li>{{ message }}</li>
        {% endfor %}
        </ul>
    {% endif %}
    {% endwith %}

    <h1>Modem Status</h1>
    <div class="tab-buttons">
    <button class="tab-button active" data-tab="modems-tab">Modems</button>
    <button class="tab-button" data-tab="table-tab">Database</button>
    <button class="tab-button" data-tab="map-tab">Map</button>
    </div>

    <div id="modems-tab" class="tab-panel active">
    <!-- start of modem square tab-->

        <div class="button-group">
            <div class="button-bar">
                <button id="startScript"><i class="fas fa-play"></i> Start</button>
                <button id="stopScript"><i class="fas fa-stop"></i> Stop</button>
            </div>
            <div class="button-bar">
                <button id="toggleAutoRefresh"><i class="fas fa-sync-alt"></i> Auto-Refresh</button>
                <button id="toggleCollapseAll">
                <i class="fas fa-compress"></i> <span>Collapse All</span></button>
                <button id="updateCallResultButton"><i class="fas fa-check-circle"></i> Update Call Results</button>
            </div>
        </div>

        <div class="status-bar">
            <span id="scriptStatus">Script: <span id="scriptStatusValue" class="badge stopped">Stopped</span></span>
            <span id="refreshStatus">Auto-Refresh: <span id="refreshStatusValue" class="badge on">On</span></span>
        </div>
        
        <div class="modem-container" id="modemContainer">
            <!-- Modem squares will be dynamically inserted here -->
        </div>

    </div><!-- end of modem square tab-->

    <div id="table-tab" class="tab-panel">
    <!-- table-tab starts here -->

        <!-- Dynamic Table That shows sql data -->
         <div class="db-button-group">
            <button class="action-button" onclick="confirmClear()">Clear Table</button>
            <button class="action-button" onclick="window.location.href='/export_csv'">Export to CSV</button>

            <form action="/import_csv" method="post" enctype="multipart/form-data" class="import-form">
                <label class="file-label">
                    <input type="file" name="file" accept=".csv" required onchange="showFileName(this)">
                    <span id="fileLabelText">Choose File</span>
                </label>
                <button type="submit" class="action-button">Import from CSV</button>
                
            </form>
        </div>

        
        <div class="table-container">
            <table id="dataTable">
                <thead>
                    <tr id="tableHeaders">
                        <!-- Headers will be dynamically populated here -->
                    </tr>
                </thead>
                <tbody>
                    <!-- Data will be dynamically populated here -->
                </tbody>
            </table>
        </div>   

    </div><!-- table-tab ends here -->

    <div id="map-tab" class="tab-panel">  
        <h5>Double click to set default location</h5>
        <div class="map-tools">
            <button onclick="confirmClearGrid()">Clear Grid Table</button>
            <button onclick="confirmRecalculateGrid()">Recalculate Grid</button>
        </div>
        <label><input type="checkbox" id="toggleMarkersLayer" checked> Show Markers Layer</label>
        <label><input type="checkbox" id="toggleGridLayer" checked> Show Grid Layer</label>
        <label><input type="checkbox" id="toggleTrailLayer" checked> Show Trail</label>
        <div id="map" style="height: 500px; border-radius: 8px; overflow: hidden;"></div>
    </div>

    <script>
        let autoRefresh = JSON.parse(localStorage.getItem('autoRefresh') || 'true');
        //let scriptRunning = false;
        const fetchDataInterval = 1000; 
        const updateCallResultInterval = 60000; //Interval for updating call result. Currently using the button instead
        const modemCollapseState = {}; // modemNumber â†’ true/false
        let collapseAll = false; // false = expanded, true = collapsed


        //Lines for button to start/stop the st_simbox script

        document.getElementById('startScript').addEventListener('click', function() {
            fetch('/start_script', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    updateStatusIndicators();
                });
        });


        document.getElementById('stopScript').addEventListener('click', function() {
            fetch('/stop_script', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    updateStatusIndicators();
                });
        });

        
        document.getElementById('toggleAutoRefresh').addEventListener('click', function() {
            autoRefresh = !autoRefresh;
            localStorage.setItem('autoRefresh', autoRefresh);
            updateStatusIndicators();
        });

        document.getElementById('updateCallResultButton').addEventListener('click', function() {
            updateCallResult();
        });


        document.getElementById('toggleCollapseAll').addEventListener('click', function () {
            const toggleBtn = this;
            const labelSpan = toggleBtn.querySelector('span');

            // Invert the global collapse mode
            const collapseAll = labelSpan.textContent.includes("Collapse");

            // Apply to all modems
            document.querySelectorAll('.modem-square').forEach(square => {
                const modemNumber = square.getAttribute('data-modem-number');
                modemCollapseState[modemNumber] = collapseAll;
                square.classList.toggle('collapsed', collapseAll);
            });

            // Update button label/icon
            labelSpan.textContent = collapseAll ? "Expand All" : "Collapse All";
            toggleBtn.querySelector('i').className = collapseAll ? "fas fa-expand" : "fas fa-compress";
        });
        




        /*Function to update call result to "ok"*/
        function updateCallResult() {
            fetch('/update_call_result', { method: 'POST' })
                .then(response => response.json())
                .then(data => console.log(data.status))
                .catch(error => console.error('Error updating CALL_RESULT:', error));
        }   

        /*Function to fetch latest modem status*/
        function fetchData() {
            if (autoRefresh) {
                fetch('/latest_json')
                    .then(response => response.json())
                    .then(data => updateModemStatus(data));
            }
        }

        function showFileName(input) {
            const fileName = input.files[0]?.name || "Choose File";
            document.getElementById('fileLabelText').textContent = fileName;
        }


        function confirmClear() {
            if (confirm("Are you sure you want to delete ALL rows in TBL_ST_SIMBOX_EVENTS?")) {
                fetch('/clear_table', { method: 'POST' })
                    .then(res => res.json())
                    .then(data => {
                        alert("Table cleared.");
                        fetchTableData(); // refresh view
                    });
            }
        }

        function updateModemStatus(data) {
            const modemContainer = document.getElementById('modemContainer');
            modemContainer.innerHTML = ''; // Clear existing modems

            const senders = data.senders || {};
            let row;

            Object.entries(senders).forEach(([modemNumber, modemData], index) => {
                if (index % 4 === 0) {
                    // Create a new row for every 4 modems
                    row = document.createElement('div');
                    row.className = 'modem-row';
                    modemContainer.appendChild(row);
                }

                const modemSquare = document.createElement('div');
                modemSquare.className = 'modem-square';
                modemSquare.setAttribute('data-modem-number', modemNumber);


		const readableTimestamp = convertEpochToReadableTime(modemData.ts);
                // Create the HTML structure with all JSON fields

                const isCollapsed = modemCollapseState[modemNumber] === true;


                modemSquare.innerHTML = `
                    <h3 class="collapsible-header">
                        <span class="arrow ${isCollapsed ? '' : 'rotated'}">&#9654;</span> Modem ${modemNumber}
                    </h3>
                    <div class="modem-details ${isCollapsed ? 'collapsed' : ''}">
                    <p><strong>Status:</strong> ${modemData.status}</p>
                    <p><strong>Error:</strong> ${modemData.error}</p>
                    <p><strong>Error Code:</strong> ${modemData.error_code}</p>
                    <p><strong>MSISDN:</strong> ${modemData.msisdn}</p>
                    <p><strong>Sent:</strong> ${modemData.sent}</p>
                    <p><strong>Modem Index I2C:</strong> ${modemData.modem_index_i2c}</p>
                    <p><strong>Timestamp:</strong> ${readableTimestamp}</p>
                    <p><strong>Network:</strong> ${modemData.network}</p>
                    <p><strong>Use Call:</strong> ${modemData.use_call}</p>
                    <p><strong>Use SMS:</strong> ${modemData.use_sms}</p>
                    <p><strong>Loopback MSISDN:</strong> ${modemData.is_loopback_msisdn}</p>
                    <p><strong>Modem MSISDN:</strong> ${modemData.modem_msisdn}</p>
                    <p><strong>Survey Results:</strong></p>
                    <ul>
                        <li><strong>Model:</strong> ${modemData.survey_results.model}</li>
                        <li><strong>IMEI:</strong> ${modemData.survey_results.imei}</li>
                        <li><strong>IMSI:</strong> ${modemData.survey_results.imsi}</li>
                        <li><strong>Registration Status:</strong> ${modemData.survey_results.registration_status}</li>
                        <li><strong>Operator:</strong> ${modemData.survey_results.operator}</li>
                        <li><strong>RAT:</strong> ${modemData.survey_results.rat}</li>
                        <li><strong>ARFCN:</strong> ${modemData.survey_results.arfcn}</li>
                        <li><strong>BSIC:</strong> ${modemData.survey_results.bsic}</li>
                        <li><strong>PSC:</strong> ${modemData.survey_results.psc}</li>
                        <li><strong>PCI:</strong> ${modemData.survey_results.pci}</li>
                        <li><strong>MCC:</strong> ${modemData.survey_results.mcc}</li>
                        <li><strong>MNC:</strong> ${modemData.survey_results.mnc}</li>
                        <li><strong>LAC:</strong> ${modemData.survey_results.lac}</li>
                        <li><strong>Cell ID:</strong> ${modemData.survey_results.cell_id}</li>
                        <li><strong>RSSI:</strong> ${modemData.survey_results.rssi}</li>
                        <li><strong>SNR:</strong> ${modemData.survey_results.snr}</li>
                        <li><strong>Call Result:</strong> ${modemData.survey_results.call_result}</li>
                        <li><strong>SMS Result:</strong> ${modemData.survey_results.sms_result}</li>
                        <li><strong>GPS coordinates:</strong> ${modemData.survey_results.gps_location}</li>
                    </ul>
                    </div>
                `;
                //Listener for collapsing modem squares

                
                modemSquare.querySelector('.collapsible-header').addEventListener('click', function() {
                    const details = this.nextElementSibling;
                    const arrow = this.querySelector('.arrow');
                    details.classList.toggle('collapsed');
                    //modemSquare.classList.toggle('collapsed'); 
                    arrow.classList.toggle('rotated');

                    // Save state if modem is collapsed or not, since page is constantly refreshing
                    modemCollapseState[modemNumber] = details.classList.contains('collapsed');
                });
                
                
                row.appendChild(modemSquare);
            });
        }

        function confirmClearGrid() {
            if (confirm("Are you sure you want to clear the grid table?")) {
                fetch('/clear_grid_table', { method: 'POST' })
                .then(res => res.json())
                .then(result => {
                    alert("Grid table cleared.");
                    loadGridLayer();
                });
            }
        }

        function confirmRecalculateGrid() {
            if (confirm("This may take a few seconds. Recalculate entire grid?")) {
                fetch('/recalculate_grid', { method: 'POST' })
                .then(res => res.json())
                .then(result => {
                    alert("Grid recalculation complete.");
                    loadGridLayer();
                });
            }
        }


        function updateStatusIndicators() {
            fetch('/get_mode')
                .then(res => res.json())
                .then(data => {
                    const mode = data.mode;
                    const scriptValue = document.getElementById('scriptStatusValue');
                    scriptValue.textContent = mode === 'start' ? 'Running' : 'Stopped';
                    scriptValue.className = 'badge ' + (mode === 'start' ? 'running' : 'stopped');
                });
            // Update refresh status locally
            const refreshValue = document.getElementById('refreshStatusValue');
            refreshValue.textContent = autoRefresh ? 'On' : 'Off';
            refreshValue.className = 'badge ' + (autoRefresh ? 'on' : 'off');
        }


	    function convertEpochToReadableTime(epoch) {
    		const date = new Date(epoch * 1000); // Convert seconds to milliseconds
    		return date.toLocaleString(); // Format as local date and time
	    }

        

        // Function to fetch data from the backend and populate the table
        function fetchTableData() {
            fetch('/fetch_table_data') // Fetches data from the Flask endpoint
                .then(response => response.json())
                .then(data => {
                    const tableHeaders = document.getElementById('tableHeaders');
                    const tbody = document.getElementById('dataTable').querySelector('tbody');

                    // Populate table headers dynamically
                    tableHeaders.innerHTML = ''; // Clear existing headers
                    data.columns.forEach(column => {
                        const th = document.createElement('th');
                        th.textContent = column.replace(/_/g, ' '); // Replace underscores with spaces for readability
                        tableHeaders.appendChild(th);
                    });

                    // Populate table rows dynamically
                    tbody.innerHTML = ''; // Clear existing rows
                    data.data.forEach(row => {
                        const tr = document.createElement('tr');
                        data.columns.forEach(column => {
                            const td = document.createElement('td');
                            td.textContent = row[column] !== null ? row[column] : ''; // Handle null values
                            tr.appendChild(td);
                        });
                        tbody.appendChild(tr);
                    });
                    // After populating headers and rows:
                    // Destroy previous DataTable if already initialized
                    if ($.fn.DataTable.isDataTable('#dataTable')) {
                        $('#dataTable').DataTable().destroy();
                    }

                    // Reinitialize DataTable
                    $('#dataTable').DataTable({
                        pageLength: 50,
                        order: [[0, 'desc']],
                        scrollX: true
                    });


                })
                .catch(err => console.error('Error fetching table data:', err));
        }

        

        

        




        //Things that happen after page content is loaded
        document.addEventListener('DOMContentLoaded', function () {
            
            //Update if script is started or stopped
            updateStatusIndicators();
            
            // Tab switching logic
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanels = document.querySelectorAll('.tab-panel');

            // Restore last tab from localStorage, or default to 'modems-tab'
            const lastTabId = localStorage.getItem('activeTab') || 'modems-tab';

            // Activate the stored/default tab
            function activateTab(tabId) {
                tabButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tab === tabId);
                });

                tabPanels.forEach(panel => {
                    panel.classList.toggle('active', panel.id === tabId);
                });
            }

            // Set initial tab
            activateTab(lastTabId);

            // Set click handlers
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.dataset.tab;
                    activateTab(tabId);
                    localStorage.setItem('activeTab', tabId); // Save to storage
                });
            });

            //Default map center and coordinate
            const savedCenter = JSON.parse(localStorage.getItem('defaultMapCenter') || '[32.0853, 34.7818]');
            const savedZoom = parseInt(localStorage.getItem('defaultMapZoom') || '10', 10);
            const map = L.map('map', { attributionControl: false }).setView(savedCenter, savedZoom);

            L.control.attribution({ prefix: false }).addTo(map);

            

            var tilesource_layer = L.tileLayer('/static/tiles/{z}/{x}/{y}.png', {
                minZoom: 0,
                maxZoom: 22,
                tms: false,
                attribution: 'Created by QGIS'
            }).addTo(map);

            //Add data layers to map
            let markersLayerGroup = L.layerGroup().addTo(map);  
            let gridLayerGroup = L.layerGroup().addTo(map);
            let trailLayerGroup = L.layerGroup().addTo(map);


            function loadGridLayer() {
                fetch('/map_grid_layer')
                .then(res => res.json())
                .then(data => {
                    gridLayerGroup.clearLayers();
                    data.forEach(square => {
                        const latMin = square.LAT_MIN;
                        const latMax = square.LAT_MAX;
                        const lonMin = square.LON_MIN;
                        const lonMax = square.LON_MAX;
                        const total = square.TOTAL_POINTS;
                        const ok = square.OK_COUNT;
                        const fail = square.FAIL_COUNT;

                        const ratio = total > 0 ? ok / total : 0;
                        let color = 'gray';
                        if (ratio >= 0.9) color = 'green';
                        else if (ratio >= 0.5) color = 'yellow';
                        else color = 'red';

                        const bounds = [
                            [latMin, lonMin],
                            [latMax, lonMax]
                        ];

                        const rectangle = L.rectangle(bounds, {
                            color: color,
                            fillOpacity: 0.3,
                            weight: 1
                        }).addTo(gridLayerGroup);

                        const percent = Math.round((ok / total) * 100);

                        rectangle.bindTooltip(
                            `Total: ${total}<br>Success: ${ok}<br>Fail: ${fail}<br>Success Rate: ${percent}%`,
                            { direction: 'top', offset: [0, -5] }
                        );

                    });
                });
            }

            // Load markers
            function loadMarkerLayer() {
                fetch('/modem_locations')
                    .then(res => res.json())
                    .then(data => {
                        markersLayerGroup.clearLayers();
                        data.forEach(item => {
                            if (!item.LATITUDE || !item.LONGITUDE) return;

                            const color = (item.CALL_RESULT === 'OK') ? 'green' : 'red';

                            const marker = L.circleMarker([item.LATITUDE, item.LONGITUDE], {
                                color: color,
                                radius: 8,
                                fillOpacity: 0.7
                            }).addTo(markersLayerGroup);

                            marker.bindTooltip(`
                                <strong>ARFCN:</strong> ${item.ARFCN || 'N/A'}<br>
                                <strong>PCI:</strong> ${item.PCI || 'N/A'}<br>
                                <strong>TIMESTAMP:</strong> ${item.TIMESTAMP || 'N/A'}<br>
                                <strong>Call Result:</strong> ${item.CALL_RESULT|| 'N/A'}
                            `, { direction: 'top', offset: [0, -5] });

                            // Full popup on click
                            let popupContent = "<strong>Full Data:</strong><br><ul style='padding-left: 15px;'>";
                            for (const key in item) {
                                popupContent += `<li><strong>${key}:</strong> ${item[key] ?? ''}</li>`;
                            }
                            popupContent += "</ul>";

                            marker.bindPopup(popupContent);
                        });
                    })
                    .catch(err => {
                        console.error('Map fetch error:', err);
                        alert("Failed to load marker layer.");
                    });
            }
            //Load trail
            function loadTrail() {
                fetch('/get_trail')
                .then(res => res.json())
                .then(data => {
                    trailLayerGroup.clearLayers();

                    if (data.length < 2) return; // need at least 2 points to draw

                    const latlngs = data.map(p => [p.LATITUDE, p.LONGITUDE]);

                    L.polyline(latlngs, {
                        color: 'orange',
                        weight: 4,
                        opacity: 0.8
                    }).addTo(trailLayerGroup);
                });
            }


            map.on('dblclick', function (e) {
                const lat = e.latlng.lat.toFixed(5);
                const lng = e.latlng.lng.toFixed(5);
                const zoom = map.getZoom();

                if (confirm(`Set default view to:\nLat: ${lat}\nLng: ${lng}\nZoom: ${zoom}?`)) {
                    localStorage.setItem('defaultMapCenter', JSON.stringify([lat, lng]));
                    localStorage.setItem('defaultMapZoom', zoom);
                    alert("Default map view saved!");
                }
            });

            document.getElementById('toggleMarkersLayer').addEventListener('change', function () {
                if (this.checked) {
                    markersLayerGroup.addTo(map);
                } else {
                    map.removeLayer(markersLayerGroup);
                }
            });

            document.getElementById('toggleGridLayer').addEventListener('change', function () {
                if (this.checked) {
                    gridLayerGroup.addTo(map);
                } else {
                    map.removeLayer(gridLayerGroup);
                }
            });

        document.getElementById('toggleTrailLayer').addEventListener('change', function () {
            if (this.checked) {
                trailLayerGroup.addTo(map);
            } else {
                map.removeLayer(trailLayerGroup);
            }
        });


            const drawnItems = new L.FeatureGroup().addTo(map);

            const drawControl = new L.Control.Draw({
                edit: {
                    featureGroup: drawnItems
                },
                draw: {
                    polygon: false,
                    rectangle: false,
                    circle: false,
                    circlemarker: false,
                    marker: false,
                    polyline: {
                        shapeOptions: {
                            color: 'orange',
                            weight: 4
                        }
                    }
                }
            });
            map.addControl(drawControl);

            map.on(L.Draw.Event.CREATED, function (e) {
            const layer = e.layer;
            drawnItems.addLayer(layer);

            const latlngs = layer.getLatLngs();

            if (confirm("Save this trail?")) {
                // Send entire polyline to server
                const trailData = latlngs.map(pt => ({
                    lat: pt.lat,
                    lon: pt.lng,
                    alt: 0  // You can extend for altitude if needed
                }));

                fetch('/save_full_trail', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(trailData)
                })
                .then(res => res.json())
                .then(result => {
                    alert("Trail saved.");
                    drawnItems.clearLayers();
                    loadTrail();
                });
            }
        });



            

            loadGridLayer();
            loadMarkerLayer();
            loadTrail();
    
            // Call fetchTableData immediately on load
            fetchTableData();

            // Start fetchData interval
            fetchData(); // Call once immediately
            setInterval(fetchData, fetchDataInterval); // Call repeatedly every second
        });    
        //updateCallResult();
        //setInterval(updateCallResult, updateCallResultInterval);

        


    </script>
</body>
</html>
