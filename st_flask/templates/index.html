<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modem Status</title>

    <!-- Link to external CSS file -->
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">

    <!-- Leaflet for map -->
    <link rel="stylesheet" href="{{ url_for('static', filename='leaflet.css') }}">
    <script src="{{ url_for('static', filename='leaflet.js') }}"></script>

    <!-- jQuery and DataTables JS for table tab-->
    <script src="{{ url_for('static', filename='jquery-3.7.1.min.js') }}"></script>
    <script src="{{ url_for('static', filename='jquery.dataTables.min.js') }}"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='jquery.dataTables.min.css') }}">

    <!-- Style for buttons-->
    <link rel="stylesheet" href="{{ url_for('static', filename='all.min.css') }}">
    
    <!-- Icon-->
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
    
    <!-- Leaflet.draw for Trail-->
    <link rel="stylesheet" href="{{ url_for('static', filename='leaflet.draw.css') }}"/>
    <script src="{{ url_for('static', filename='leaflet.draw.js') }}"></script>

    <script src="{{ url_for('static', filename='typed.js@2.0.12') }}"></script>

    <!-- Leaflet For marker cluster-->
    <link rel="stylesheet" href="{{ url_for('static', filename='MarkerCluster.css') }}" />
    <link rel="stylesheet" href="{{ url_for('static', filename='MarkerCluster.Default.css') }}" />
    <script src="{{ url_for('static', filename='leaflet.markercluster.js') }}"></script>



    




</head>
<body>

    <!-- Flash messages -->
    {% with messages = get_flashed_messages() %}
    {% if messages %}
        <ul class="flash-messages">
        {% for message in messages %}
            <li>{{ message }}</li>
        {% endfor %}
        </ul>
    {% endif %}
    {% endwith %}

    <div class="main-header"><i class="fas fa-sim-card"></i> Simbox Tester</div>


    <div class="status-bar"> 
        <span id="batteryPercentStatus">Battery:<span id="batteryPercentValue" class="badge battery-grey">Unknown</span></span>
        <span id="batteryStatusIndicator">Status:<span id="batteryStatusValue" class="badge battery-grey">Unknown</span></span>
        <span id="gpsStatusMain">GPS: <span id="gpsStatusValue" class="badge">Checking...</span></span>
    </div>     


    <!-- Toggle simple/advanced mode -->
    <div class="mode-toggle">
    <button id="modeToggleButton">
        <i class="fas fa-cogs"></i> Switch to Advanced Mode
    </button>
    </div>

    <div id="tabContainer">
    <div class="primary-button-container">
        <div class="primary-button-group">
            <button class="tab-button active" data-tab="main-tab"><i class="fas fa-house"></i> Main</button>
            <button class="tab-button" data-tab="modems-tab"><i class="fas fa-mobile"></i> Modems</button>
            <button class="tab-button" data-tab="table-tab"><i class="fas fa-database"></i> Database</button>
            <button class="tab-button" data-tab="map-tab"><i class="fas fa-map"></i> Map</button>
            <button class="tab-button" data-tab="settings-tab"><i class="fas fa-sliders-h"></i> Settings</button>

        </div>
    </div>
    </div>

    <div id="main-tab" class="tab-panel active">
        <div class="secondary-button-group">
            <div class="button-bar">
                <button id="startScript"><i class="fas fa-play"></i> Start</button>
                <button id="stopScript"><i class="fas fa-stop"></i> Stop</button>
            </div>
        </div>

        <div class="status-bar">
            <span id="scriptStatusMain">Frontend:<span id="scriptStatusValue" class="badge stopped">Stopped</span></span>
            <span id="surveyStatus">Backend:<span id="surveyStatusValue" class="badge">Unknown</span></span>
            <span id="messageCounter">Events:<span id="messageCounterValue" class="badge">0</span></span>
            <span id="goalProgress">Progress:<span id="goalProgressValue" class="badge goal-grey">-</span></span>
        </div>
        <div class="map-lock-container">
        <label class="lock-toggle">
            <input type="checkbox" id="lockMapCheckbox">
            <span class="checkmark"></span>
            Lock Map
        </label>
        <button id="centerMainMapButton" ><i class="fas fa-crosshairs"></i> Center Map</button>
        </div>

        <div id="mainMap" style="height: 400px; border-radius: 8px; margin-top: 20px;"></div>
    </div>


    <div id="modems-tab" class="tab-panel">
    <!-- start of modem square tab-->

        <div class="secondary-button-group">
            <div class="button-bar">
                <button id="toggleAutoRefresh"><i class="fas fa-sync-alt"></i> Auto-Refresh</button>
                <button id="toggleCollapseAll">
                <i class="fas fa-compress"></i> <span>Collapse All</span></button>
                <button id="updateCallResultButton"><i class="fas fa-check-circle"></i> Update Call Results</button>
            </div>
        </div>

        <div class="status-bar">
            <span id="refreshStatus">Auto-Refresh: <span id="refreshStatusValue" class="badge on">On</span></span>
            <span id="batteryStatus">Battery voltage:<span id="batteryValue" class="badge battery-grey">Unknown</span></span>
        </div>
        
        <div class="modem-container" id="modemContainer">
            <!-- Modem squares will be dynamically inserted here -->
        </div>

    </div><!-- end of modem square tab-->

    <div id="table-tab" class="tab-panel">
    <!-- table-tab starts here -->

        <!-- Dynamic Table That shows sql data -->
        <div class="secondary-button-group">
            <button class="action-button" onclick="confirmClear()"><i class="fas fa-trash"></i> Clear Table</button>
            <button class="action-button" onclick="window.location.href='/export_csv'"><i class="fas fa-file-excel"></i> Export to CSV</button>

            <form action="/import_csv" method="post" enctype="multipart/form-data" class="import-form">
                <div class="import-button-group">
                    <label class="file-label">
                        <input type="file" name="file" accept=".csv"  onchange="showFileName(this)">
                        <span id="fileLabelText"><i class="fas fa-file"></i> Choose File</span>
                    </label>
                    <button type="submit" class="action-button"><i class="fas fa-cloud-upload"></i> Import</button>
                </div>
            </form>
        </div>


        
        <div class="table-container">
            <table id="dataTable">
                <thead>
                    <tr id="tableHeaders">
                        <!-- Headers will be dynamically populated here -->
                    </tr>
                </thead>
                <tbody>
                    <!-- Data will be dynamically populated here -->
                </tbody>
            </table>
        </div>   

    </div><!-- table-tab ends here -->

    <div id="map-tab" class="tab-panel">  
        <h5>Double click to set Current location</h5>
        <div class="secondary-button-group">
            <button onclick="confirmClearGrid()"><i class="fas fa-trash"></i> Clear Grid Table</button>
            <button onclick="confirmRecalculateGrid()"><i class="fas fa-calculator"></i> Recalculate Grid</button>
        </div>
        <div class="layer-toggle-group">
            <label><input type="checkbox" id="toggleMarkersLayer" checked> Show Markers Layer</label>
            <label><input type="checkbox" id="toggleGridLayer" checked> Show Grid Layer</label>
            <label><input type="checkbox" id="toggleTrailLayer" checked> Show Trail</label>
            <label><input type="checkbox" id="toggleRssiLayer" checked> Show RSSI layer</label>
        </div>
        <div id="map" style="height: 500px; border-radius: 8px; overflow: hidden;"></div>
    </div>

    <div id="settings-tab" class="tab-panel">
    <h2>Configuration Settings</h2>
    <form id="settingsForm">
        <label>
        Session Name:
        <input type="text" name="session_name">
        </label><br>

        <label>
        Receiving Goal:
        <input type="number" name="receiving_goal">
        </label><br>

        <label>
        Default Latitude:
        <input type="text" name="default_latitude">
        </label><br>

        <label>
        Default Longitude:
        <input type="text" name="default_longitude">
        </label><br>

        <label>
        Use Browser Geolocation:
        <input type="checkbox" name="use_geolocation">
        </label><br><br>

        <button type="submit">Save Settings</button>
    </form>
    </div>


    <script>

        let receivingGoal = 0;//Goal of messages to be received from simbox
        
        window.MAX_ZOOM=19;//Maximum zoom level in map
        
        let messageCounter = 0;//Number of messages with non-empty "senders" segment
        let autoRefresh = JSON.parse(localStorage.getItem('autoRefresh') || 'true');
        
        //let scriptRunning = false;
        const fetchDataInterval = 1000; 
        const updateCallResultInterval = 60000; //Interval for updating call result. Currently using the button instead
        const modemCollapseState = {}; // modemNumber → true/false
        let collapseAll = false; // false = expanded, true = collapsed


    
        //Will print message if no file was chosen
        document.querySelector('.import-form').addEventListener('submit', function(e) {
            const fileInput = this.querySelector('input[type="file"]');
            if (!fileInput.value) {
                alert('Please choose a CSV file to import.');
                e.preventDefault();
            }
        });

        //Center to default location button
        document.getElementById('centerMainMapButton').addEventListener('click', function() {
            if (window.db_center && window.mainMap) {
                window.mainMap.setView(window.db_center, window.mainMap.getZoom());
            } else {
                alert("Default center not available.");
            }
        });



        
        //Toggle advanced/basic mode
        document.getElementById('modeToggleButton').addEventListener('click', function() {
            const body = document.body;
            body.classList.toggle('advanced-mode');

            // Save state in localStorage
            const isAdvanced = body.classList.contains('advanced-mode');
            localStorage.setItem('mode', isAdvanced ? 'advanced' : 'stupid');

            // Update button text
            if (isAdvanced) {
                this.innerHTML = '<i class="fas fa-cogs"></i> Switch to Simple Mode';
            } else {
                this.innerHTML = '<i class="fas fa-cogs"></i> Switch to Advanced Mode';
            }

            // Activate first tab if none
            if (isAdvanced) {
                const anyActive = document.querySelector('.tab-button.active');
                if (!anyActive) {
                const firstButton = document.querySelector('.tab-button');
                if (firstButton) {
                    firstButton.classList.add('active');
                    const targetId = firstButton.dataset.tab;
                    document.querySelectorAll('.tab-panel').forEach(panel => {
                    panel.classList.toggle('active', panel.id === targetId);
                    });
                }
                }
            }
        });




        //Lines for button to start/stop the st_simbox backend. It responds by start or stop request
        function updateStartStopButtons(mode) {
            const startBtn = document.getElementById('startScript');
            const stopBtn = document.getElementById('stopScript');

            if (mode === 'start') {
                startBtn.classList.add('active');
                stopBtn.classList.remove('active');
            } else {
                stopBtn.classList.add('active');
                startBtn.classList.remove('active');
            }

            // Optional: update status text
            /*const statusSpan = document.getElementById('scriptStatusValue');
            if (statusSpan) {
                statusSpan.textContent = (mode === 'start') ? 'Running' : 'Stopped';
                statusSpan.style.color = (mode === 'start') ? 'lime' : 'red';
            }*/
        }

        // On page load, fetch current state
        document.addEventListener('DOMContentLoaded', function() {
            fetch('/get_mode')
                .then(res => res.json())
                .then(data => {
                updateStartStopButtons(data.mode);
                });
        });

        // Start button click
        document.getElementById('startScript').addEventListener('click', function() {
            fetch('/start_script', { method: 'POST' })
                .then(() => {
                updateStartStopButtons('start');
                messageCounter = 0;
                updateMessageCounterDisplay();
                });
        });

        // Stop button click
        document.getElementById('stopScript').addEventListener('click', function() {
            fetch('/stop_script', { method: 'POST' })
                .then(() => {
                updateStartStopButtons('stop');
                });
        });


        
        document.getElementById('toggleAutoRefresh').addEventListener('click', function() {
            autoRefresh = !autoRefresh;
            localStorage.setItem('autoRefresh', autoRefresh);
            updateStatusIndicators();
        });

        document.getElementById('updateCallResultButton').addEventListener('click', function() {
            updateCallResult();
        });


        document.getElementById('toggleCollapseAll').addEventListener('click', function () {
            const toggleBtn = this;
            const labelSpan = toggleBtn.querySelector('span');

            // Invert the global collapse mode
            const collapseAll = labelSpan.textContent.includes("Collapse");

            // Apply to all modems
            document.querySelectorAll('.modem-square').forEach(square => {
                const modemNumber = square.getAttribute('data-modem-number');
                modemCollapseState[modemNumber] = collapseAll;
                square.classList.toggle('collapsed', collapseAll);
            });

            // Update button label/icon
            labelSpan.textContent = collapseAll ? "Expand All" : "Collapse All";
            toggleBtn.querySelector('i').className = collapseAll ? "fas fa-expand" : "fas fa-compress";
        });
        




        /*Function to update call result to "ok"*/
        function updateCallResult() {
            fetch('/update_call_result', { method: 'POST' })
                .then(response => response.json())
                .then(data => console.log(data.status))
                .catch(error => console.error('Error updating CALL_RESULT:', error));
        }   

        /*Function to fetch latest modem status*/
        function fetchData() {
            if (autoRefresh) {
                fetch('/latest_json')
                    .then(response => response.json())
                    .then(data => {
                        if (data.senders && Object.keys(data.senders).length > 0) {
                            updateModemStatus(data);
                            messageCounter++;  // Increment number of non-empty messages
                            updateMessageCounterDisplay();
                        } else {
                            console.log("Empty modem data; skipping modem update");
                        }
                        updateStatusIndicators();
                    });
            }
        }

        //Update number of non-empty messages
        function updateMessageCounterDisplay() {
            const counterValue = document.getElementById('messageCounterValue');
            counterValue.textContent = messageCounter;
            counterValue.className = 'badge ' + (messageCounter === 0 ? 'counter-zero' : 'counter-active');
            // Save to localStorage
            localStorage.setItem('messageCounter', messageCounter);

            // Update the progress
            updateGoalProgressIndicator();

        }

        //Update progress percentage
        function updateGoalProgressIndicator() {
            const goalProgressValue = document.getElementById('goalProgressValue');

            if (!receivingGoal || receivingGoal <= 0) {
                goalProgressValue.textContent = "-";
                goalProgressValue.className = "badge goal-grey";
                return;
            }

            const percent = Math.min(100, Math.round((messageCounter / receivingGoal) * 100));
            goalProgressValue.textContent = percent + "%";

            if (percent >= 80) {
                goalProgressValue.className = "badge goal-green";
            } else if (percent >= 50) {
                goalProgressValue.className = "badge goal-orange";
            } else {
                goalProgressValue.className = "badge goal-red";
            }
        }




        function showFileName(input) {
            const fileName = input.files[0]?.name || "Choose File";
            document.getElementById('fileLabelText').textContent = fileName;
        }


        function confirmClear() {
            if (confirm("Are you sure you want to delete ALL rows in TBL_ST_SIMBOX_EVENTS?")) {
                fetch('/clear_table', { method: 'POST' })
                    .then(res => res.json())
                    .then(data => {
                        alert("Table cleared.");
                        fetchTableData(); // refresh view
                    });
            }
        }

        function updateModemStatus(data) {
            const modemContainer = document.getElementById('modemContainer');
            modemContainer.innerHTML = ''; // Clear existing modems

            const senders = data.senders || {};
            let row;

            Object.entries(senders).forEach(([modemNumber, modemData], index) => {
                if (index % 4 === 0) {
                    // Create a new row for every 4 modems
                    row = document.createElement('div');
                    row.className = 'modem-row';
                    modemContainer.appendChild(row);
                }

                const modemSquare = document.createElement('div');
                modemSquare.className = 'modem-square';
                modemSquare.setAttribute('data-modem-number', modemNumber);


		const readableTimestamp = convertEpochToReadableTime(modemData.ts);
                // Create the HTML structure with all JSON fields

                const isCollapsed = modemCollapseState[modemNumber] === true;


                modemSquare.innerHTML = `
                    <h3 class="collapsible-header">
                        <span class="arrow ${isCollapsed ? '' : 'rotated'}">&#9654;</span> Modem ${modemNumber}
                    </h3>
                    <div class="modem-details ${isCollapsed ? 'collapsed' : ''}">
                    <p><strong>Status:</strong> ${modemData.status}</p>
                    <p><strong>Error:</strong> ${modemData.error}</p>
                    <p><strong>Error Code:</strong> ${modemData.error_code}</p>
                    <p><strong>MSISDN:</strong> ${modemData.msisdn}</p>
                    <p><strong>Sent:</strong> ${modemData.sent}</p>
                    <p><strong>Modem Index I2C:</strong> ${modemData.modem_index_i2c}</p>
                    <p><strong>Timestamp:</strong> ${readableTimestamp}</p>
                    <p><strong>Network:</strong> ${modemData.network}</p>
                    <p><strong>Use Call:</strong> ${modemData.use_call}</p>
                    <p><strong>Use SMS:</strong> ${modemData.use_sms}</p>
                    <p><strong>Loopback MSISDN:</strong> ${modemData.is_loopback_msisdn}</p>
                    <p><strong>Modem MSISDN:</strong> ${modemData.modem_msisdn}</p>
                    <p><strong>Survey Results:</strong></p>
                    <ul>
                        <li><strong>Model:</strong> ${modemData.survey_results.model}</li>
                        <li><strong>IMEI:</strong> ${modemData.survey_results.imei}</li>
                        <li><strong>IMSI:</strong> ${modemData.survey_results.imsi}</li>
                        <li><strong>Registration Status:</strong> ${modemData.survey_results.registration_status}</li>
                        <li><strong>Operator:</strong> ${modemData.survey_results.operator}</li>
                        <li><strong>RAT:</strong> ${modemData.survey_results.rat}</li>
                        <li><strong>ARFCN:</strong> ${modemData.survey_results.arfcn}</li>
                        <li><strong>BSIC:</strong> ${modemData.survey_results.bsic}</li>
                        <li><strong>PSC:</strong> ${modemData.survey_results.psc}</li>
                        <li><strong>PCI:</strong> ${modemData.survey_results.pci}</li>
                        <li><strong>MCC:</strong> ${modemData.survey_results.mcc}</li>
                        <li><strong>MNC:</strong> ${modemData.survey_results.mnc}</li>
                        <li><strong>LAC:</strong> ${modemData.survey_results.lac}</li>
                        <li><strong>Cell ID:</strong> ${modemData.survey_results.cell_id}</li>
                        <li><strong>RSSI:</strong> ${modemData.survey_results.rssi}</li>
                        <li><strong>SNR:</strong> ${modemData.survey_results.snr}</li>
                        <li><strong>Call Result:</strong> ${modemData.survey_results.call_result}</li>
                        <li><strong>SMS Result:</strong> ${modemData.survey_results.sms_result}</li>
                        <li><strong>GPS coordinates:</strong> ${modemData.survey_results.gps_location}</li>
                    </ul>
                    </div>
                `;
                //Listener for collapsing modem squares

                
                modemSquare.querySelector('.collapsible-header').addEventListener('click', function() {
                    const details = this.nextElementSibling;
                    const arrow = this.querySelector('.arrow');
                    details.classList.toggle('collapsed');
                    //modemSquare.classList.toggle('collapsed'); 
                    arrow.classList.toggle('rotated');

                    // Save state if modem is collapsed or not, since page is constantly refreshing
                    modemCollapseState[modemNumber] = details.classList.contains('collapsed');
                });
                
                
                row.appendChild(modemSquare);
            });
        }

        function confirmClearGrid() {
            if (confirm("Are you sure you want to clear the grid table?")) {
                fetch('/clear_grid_table', { method: 'POST' })
                .then(res => res.json())
                .then(result => {
                    alert("Grid table cleared.");
                    loadRssiLayer();
                    loadGridLayer();
                });
            }
        }

        function confirmRecalculateGrid() {
            if (confirm("This may take a few seconds. Recalculate entire grid?")) {
                fetch('/recalculate_grid', { method: 'POST' })
                .then(res => res.json())
                .then(result => {
                    alert("Grid recalculation complete.");
                    loadRssiLayer();
                    loadGridLayer();
                });
            }
        }


        function updateStatusIndicators() {
            fetch('/get_mode')
                .then(res => res.json())
                .then(data => {
                    const mode = data.mode;
                    const scriptValue = document.getElementById('scriptStatusValue');
                    scriptValue.textContent = mode === 'start' ? 'Running' : 'Stopped';
                    scriptValue.className = 'badge ' + (mode === 'start' ? 'running' : 'stopped');

                    // GPS status
                    const gpsValue = document.getElementById('gpsStatusValue');
                    if (data.gps_location && data.gps_location.trim() !== "") {
                        gpsValue.textContent = 'Up';
                        gpsValue.className = 'badge gps-up';
                    } else {
                        gpsValue.textContent = 'Down';
                        gpsValue.className = 'badge gps-down';
                    }

                    //Status of backend service
                    const surveyValue = document.getElementById('surveyStatusValue');
                    if (data.survey_running === true) {
                        surveyValue.textContent = 'Running';
                        surveyValue.className = 'badge survey-running';
                    } else if (data.survey_running === false) {
                        surveyValue.textContent = 'Stopped';
                        surveyValue.className = 'badge survey-stopped';
                    } else {
                        surveyValue.textContent = 'Unknown';
                        surveyValue.className = 'badge survey-unknown';
                    }

                    //Status of battery
                    updateBatteryIndicator(data.battery_voltage,data.battery_status);

                });
            // Update refresh status locally
            const refreshValue = document.getElementById('refreshStatusValue');
            refreshValue.textContent = autoRefresh ? 'On' : 'Off';
            refreshValue.className = 'badge ' + (autoRefresh ? 'on' : 'off');
        }

            function updateBatteryIndicator(voltage,status) {
            const batteryValue = document.getElementById('batteryValue');
            const batteryPercentValue = document.getElementById('batteryPercentValue');

            if (voltage === undefined || voltage === null || isNaN(voltage) || voltage == "") {
                batteryValue.textContent = "Unknown";
                batteryPercentValue.textContent = "Unknown";
                batteryValue.className = "badge battery-grey";
                batteryPercentValue.className = "badge battery-grey";
                return;
            }
            batteryValue.textContent = voltage.toFixed(2) + " V";

            // Calculate percentage
            let percent = ((voltage - 6.4) / (8.3 - 6.4)) * 100;
            percent = Math.max(0, Math.min(100, percent));
            const percentText = percent.toFixed(0) + "%";
            batteryPercentValue.textContent = percentText;

            if (voltage >= 8.0) {
                batteryValue.className = "badge battery-green";
            } else if (voltage >= 7.0) {
                batteryValue.className = "badge battery-orange";
            } else {
                batteryValue.className = "badge battery-red";
            }

            // Percentage color 
            if (percent >= 75) {
                batteryPercentValue.className = "badge battery-green";
            } else if (percent >= 40) {
                batteryPercentValue.className = "badge battery-orange";
            } else {
                batteryPercentValue.className = "badge battery-red";
            }

            //Charging status
            const batteryStatusValue = document.getElementById('batteryStatusValue');
            if (!status || status === "Unknown") {
                batteryStatusValue.textContent = "Unknown";
                batteryStatusValue.className = "badge battery-unknown";
                return;
            }
            if (status.toLowerCase() === "charging") {
                batteryStatusValue.textContent = "Charging";
                batteryStatusValue.className = "badge battery-charging";
            } 
            else if (status.toLowerCase() === "discharging"){
                batteryStatusValue.textContent = "Discharging";
                batteryStatusValue.className = "badge battery-discharging";
            }
            else{
                batteryStatusValue.textContent = "Unknown";
                batteryStatusValue.className = "badge battery-unknown";
            }
        }



	    function convertEpochToReadableTime(epoch) {
    		const date = new Date(epoch * 1000); // Convert seconds to milliseconds
    		return date.toLocaleString(); // Format as local date and time
	    }

        

        // Function to fetch data from the backend and populate the table
        function fetchTableData() {
            fetch('/fetch_table_data') // Fetches data from the Flask endpoint
                .then(response => response.json())
                .then(data => {
                    const tableHeaders = document.getElementById('tableHeaders');
                    const tbody = document.getElementById('dataTable').querySelector('tbody');

                    // Populate table headers dynamically
                    tableHeaders.innerHTML = ''; // Clear existing headers
                    data.columns.forEach(column => {
                        const th = document.createElement('th');
                        th.textContent = column.replace(/_/g, ' '); // Replace underscores with spaces for readability
                        tableHeaders.appendChild(th);
                    });

                    // Populate table rows dynamically
                    tbody.innerHTML = ''; // Clear existing rows
                    data.data.forEach(row => {
                        const tr = document.createElement('tr');
                        data.columns.forEach(column => {
                            const td = document.createElement('td');
                            td.textContent = row[column] !== null ? row[column] : ''; // Handle null values
                            tr.appendChild(td);
                        });
                        tbody.appendChild(tr);
                    });
                    // After populating headers and rows:
                    // Destroy previous DataTable if already initialized
                    if ($.fn.DataTable.isDataTable('#dataTable')) {
                        $('#dataTable').DataTable().destroy();
                    }

                    // Reinitialize DataTable
                    $('#dataTable').DataTable({
                        pageLength: 50,
                        order: [[0, 'desc']],
                        scrollX: true
                    });


                })
                .catch(err => console.error('Error fetching table data:', err));
        }

        function showFlashMessage(message) {
            const flashContainer = document.querySelector('.flash-messages');
            if (!flashContainer) return;

            const li = document.createElement('li');
            li.textContent = message;
            flashContainer.appendChild(li);
        }


        //Edit trail description. this is outside of DOM segment because popup is outside of function scope
        function editDescription(trailId, lat, lon) {
                const newDescription = prompt("Enter new description:");
                if (newDescription !== null) {
                    fetch('/update_trail_description', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            trail_id: trailId,
                            lat: lat,
                            lon: lon,
                            description: newDescription
                        })
                    })
                    .then(res => res.json())
                    .then(result => {
                        alert("Description updated.");
                        loadTrail(); // Reload to reflect changes
                        loadMainMapTrail();
                    });
                }
            }

        
            function deleteTrail(trailId) {
                fetch(`/delete_trail/${trailId}`, { method: 'POST' })
                .then(res => res.json())
                .then(result => {
                    alert("Trail deleted.");
                    loadTrail();
                });
            }

            //=======Functions to add layers to map in map tab=====================

            //Load trail
            function loadTrail() {
                fetch('/get_trail')
                .then(res => res.json())
                .then(data => {
                    trailLayerGroup.clearLayers();

                    const trails = {};

                    data.forEach(item => {
                        if (!trails[item.TRAIL_ID]) {
                            trails[item.TRAIL_ID] = [];
                        }
                        trails[item.TRAIL_ID].push(item);
                    });

                    for (const trailId in trails) {
                        const points = trails[trailId];

                        const latlngs = points.map(trailPoint => [trailPoint.LATITUDE, trailPoint.LONGITUDE]);

                        const polyline = L.polyline(latlngs, {
                            color: 'black',
                            weight: 5,
                            opacity: 1.0,
                            dashArray: '10,6',
                            lineCap: 'round',
                            pane: 'trailMarkerPane'
                        }).addTo(trailLayerGroup);

                        points.forEach((trailPoint, index) => {
                            const latlng = [trailPoint.LATITUDE, trailPoint.LONGITUDE];
                            const number = index + 1;

                            const iconHtml = (number, marked) => `
                                <div style="
                                    width: 24px;
                                    height: 24px;
                                    background-color: ${marked ? '#3a5ba0' : 'white'};
                                    border: 2px solid black;
                                    border-radius: 4px;
                                    text-align: center;
                                    line-height: 24px;
                                    font-weight: bold;
                                    font-size: 14px;
                                    color: ${marked ? 'white' : 'black'};
                                ">
                                    ${number}
                                </div>
                            `;

                            const marker = L.marker(latlng, {
                            icon: L.divIcon({
                                html: iconHtml(number, trailPoint.IS_MARKED),
                                className: '',
                                iconSize: [24, 24],
                                iconAnchor: [12, 12]
                            }),
                            pane: 'trailPane'
                            }).addTo(trailLayerGroup);

                            marker.isSelected = trailPoint.IS_MARKED;

                            let description = trailPoint.DESCRIPTION || "Unknown location";

                            marker.bindPopup(`
                            <div class="popup-content">
                                <div class="popup-header">
                                    <b>Location</b>
                                    <button class="edit-button" onclick="editDescription(${trailPoint.TRAIL_ID}, ${trailPoint.LATITUDE}, ${trailPoint.LONGITUDE})">Edit</button>
                                    <button class="edit-button" onclick="setAsDefaultLocation(${trailPoint.LATITUDE}, ${trailPoint.LONGITUDE})">Set as current location</button>
                                </div>
                                <div class="popup-description">${description}</div>
                            </div>
                        `, { className: 'custom-popup' });

                        
                        });

                        polyline.on('click', function() {
                            if (confirm(`Delete trail ID ${trailId}?`)) {
                                deleteTrail(trailId);
                            }
                        });
                    }


                });
            }
            //Load Grid
            function loadGridLayer() {
                fetch('/map_grid_layer')
                .then(res => res.json())
                .then(data => {
                    gridLayerGroup.clearLayers();
                    data.forEach(square => {
                        const latMin = square.LAT_MIN;
                        const latMax = square.LAT_MAX;
                        const lonMin = square.LON_MIN;
                        const lonMax = square.LON_MAX;
                        const total = square.TOTAL_POINTS;
                        const ok = square.OK_COUNT;
                        const fail = square.FAIL_COUNT;

                        const failRatio = (square.TOTAL_POINTS - square.OK_COUNT) / square.TOTAL_POINTS;

                        const color = (failRatio > 0.9) ? 'red' :
                                      (failRatio > 0.5) ? 'yellow' : 'green';


                        const bounds = [
                            [latMin, lonMin],
                            [latMax, lonMax]
                        ];

                        const rectangle = L.rectangle(bounds, {
                            color: color,
                            fillOpacity: 0.3,
                            weight: 1,
                            pane: 'gridPane'
                        }).addTo(gridLayerGroup);

                        const percent = Math.round((ok / total) * 100);

                        rectangle.bindTooltip(
                            `Total: ${total}<br>Success: ${ok}<br>Fail: ${fail}<br>Success Rate: ${percent}%`,
                            { direction: 'top', offset: [0, -5] }
                        );

                    });
                });
                
            }

function loadRssiLayer() {
  fetch('/rssi_grid')
    .then(res => res.json())
    .then(data => {
      window.rssiLayerGroup.clearLayers();

      data.forEach(item => {
        const lat = (item.LAT_MIN + item.LAT_MAX) / 2;
        const lon = (item.LON_MIN + item.LON_MAX) / 2;
        const avgRssi = item.RSSI_SUM / item.TOTAL_POINTS;

        // Color: green for good RSSI, red for poor
        let color = 'green';
        if (avgRssi < -100) color = 'red';
        else if (avgRssi < -85) color = 'orange';
        else if (avgRssi < -70) color = 'yellow';

        // CircleMarker with more opacity blending
        const marker = L.circleMarker([lat, lon], {
            radius: 25,
            fillColor: color,
            fillOpacity: 0.25,
            color: color,
            opacity: 0.1,     // thin border halo
            weight: 8,
            pane: 'rssiPane'
        }).addTo(window.rssiLayerGroup);

        // Label in center
        marker.bindTooltip(
          `RSSI: ${avgRssi.toFixed(1)} dBm`,
          { 
            permanent: true, 
            direction: 'center', 
            className: 'rssi-label' 
          }
        );
      });
    });
}








            // Load markers
            function loadMarkerLayer() {
                fetch('/modem_locations')
                    .then(res => res.json())
                    .then(data => {
                        markersLayerGroup.clearLayers();
                        data.forEach(item => {
                            if (!item.LATITUDE || !item.LONGITUDE) return;

                            let color = 'gray';  // fallback
                            let results = [];    // declare results here so it's always defined

                            try {
                                results = JSON.parse(item.CALL_RESULT || '[]');
                                const total = results.length;
                                const failed = results.filter(r => r.toLowerCase() !== 'ok').length;
                                const failRatio = total > 0 ? failed / total : 0;

                                if (failRatio > 0.9) {
                                    color = 'red';
                                } else if (failRatio > 0.5) {
                                    color = 'yellow';
                                } else {
                                    color = 'green';
                                }
                            } catch (e) {
                                console.warn('Failed to parse CALL_RESULT:', item.CALL_RESULT);
                            }


                            const marker = L.circleMarker([item.LATITUDE, item.LONGITUDE], {
                                color: color,
                                radius: 8,
                                fillOpacity: 0.7,
                                pane: 'markerPane',
                                callResult: JSON.stringify(results)  // save array as string
                            }).addTo(markersLayerGroup);

                            // Compute call result ratio
                            let callResultText = 'N/A';
                            try {
                                const results = JSON.parse(item.CALL_RESULT || '[]');
                                const total = results.length;
                                const okCount = results.filter(r => r.toLowerCase() === 'ok').length;
                                const successRate = total > 0 ? (okCount / total) * 100 : 0;
                                callResultText = `${okCount} out of ${total} → ${successRate.toFixed(1)}%`;
                            } catch (e) {
                                console.warn("Invalid CALL_RESULT format", item.CALL_RESULT);
                            }

                            marker.bindTooltip(`
                                <strong>ARFCN:</strong> ${item.ARFCN || 'N/A'}<br>
                                <strong>PCI:</strong> ${item.PCI || 'N/A'}<br>
                                <strong>Operator:</strong> ${item.OPERATOR || 'N/A'}<br>
                                <strong>TIMESTAMP:</strong> ${item.TIMESTAMP || 'N/A'}<br>
                                <strong>Successful calls:</strong> ${callResultText}
                            `, { direction: 'top', offset: [0, -5] });

                            // Full popup on click
                            let popupContent = "<strong>Full Data:</strong><br><ul style='padding-left: 15px;'>";
                            for (const key in item) {
                                popupContent += `<li><strong>${key}:</strong> ${item[key] ?? ''}</li>`;
                            }
                            popupContent += "</ul>";

                            marker.bindPopup(popupContent);
                        });
                    })
                    .catch(err => {
                        console.error('Map fetch error:', err);
                        alert("Failed to load marker layer.");
                    });
            }

            function loadMainMapTrail() {
                fetch('/get_trail')
                .then(res => res.json())
                .then(data => {
                    trailLayerGroupMain.clearLayers();

                    const trails = {};

                    data.forEach(item => {
                        if (!trails[item.TRAIL_ID]) {
                            trails[item.TRAIL_ID] = [];
                        }
                        trails[item.TRAIL_ID].push(item);
                    });

                    for (const trailId in trails) {
                        const points = trails[trailId];

                        const latlngs = points.map(trailPoint => [trailPoint.LATITUDE, trailPoint.LONGITUDE]);

                        const polyline = L.polyline(latlngs, {
                            color: 'black',
                            weight: 5,
                            opacity: 1.0,
                            dashArray: '10,6',
                            lineCap: 'round',
                            pane: 'trailMarkerPane'
                        }).addTo(trailLayerGroupMain);

                        points.forEach((trailPoint, index) => {
                            const latlng = [trailPoint.LATITUDE, trailPoint.LONGITUDE];
                            const number = index + 1;

                            const iconHtml = (number, marked) => `
                                <div style="
                                    width: 24px;
                                    height: 24px;
                                    background-color: ${marked ? '#3a5ba0' : 'white'};
                                    border: 2px solid black;
                                    border-radius: 4px;
                                    text-align: center;
                                    line-height: 24px;
                                    font-weight: bold;
                                    font-size: 14px;
                                    color: ${marked ? 'white' : 'black'};
                                ">
                                    ${number}
                                </div>
                            `;

                            const marker = L.marker(latlng, {
                            icon: L.divIcon({
                                html: iconHtml(number, trailPoint.IS_MARKED),
                                className: '',
                                iconSize: [24, 24],
                                iconAnchor: [12, 12]
                            }),
                            pane: 'trailPane'
                            }).addTo(trailLayerGroupMain);

                            marker.isSelected = trailPoint.IS_MARKED;

                            marker.on('dblclick', function () {
                                this.isSelected = !this.isSelected;

                                this.setIcon(L.divIcon({
                                    html: iconHtml(number, this.isSelected),
                                    className: '',
                                    iconSize: [24, 24],
                                    iconAnchor: [12, 12]
                                }));

                                fetch('/update_marker_status', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        trail_id: trailPoint.TRAIL_ID,
                                        lat: trailPoint.LATITUDE,
                                        lon: trailPoint.LONGITUDE,
                                        is_marked: this.isSelected
                                    })
                                });


                            });


                            let description = trailPoint.DESCRIPTION || "Unknown location";

                            marker.bindPopup(`
                            <div class="popup-content">
                                <div class="popup-header">
                                    <b>Location</b>
                                    <button class="edit-button" onclick="editDescription(${trailPoint.TRAIL_ID}, ${trailPoint.LATITUDE}, ${trailPoint.LONGITUDE})">Edit</button>
                                    <button class="edit-button" onclick="setAsDefaultLocation(${trailPoint.LATITUDE}, ${trailPoint.LONGITUDE})">Set as current location</button>
                                </div>
                                <div class="popup-description">${description}</div>
                            </div>
                        `, { className: 'custom-popup' });

                        
                        });

                        polyline.on('click', function() {
                            if (confirm(`Delete trail ID ${trailId}?`)) {
                                deleteMainMapTrail(trailId);
                            }
                        });

                        

                    }


                });
            }
            function deleteMainMapTrail(trailId) {
                fetch(`/delete_trail/${trailId}`, { method: 'POST' })
                .then(res => res.json())
                .then(result => {
                    alert("Trail deleted.");
                    loadMainMapTrail();
                });
            }

            //Settings tab functions
            function loadSettings() {
                fetch('/get_settings')
                    .then(res => res.json())
                    .then(data => {
                    const form = document.getElementById('settingsForm');
                    form.session_name.value = data.session_name || '';
                    form.receiving_goal.value = data.receiving_goal || '';
                    receivingGoal = parseInt(form.receiving_goal.value, 10) || 0; //Put receiving goal into a variable
                    form.default_latitude.value = data.default_latitude || '';
                    form.default_longitude.value = data.default_longitude || '';
                    form.use_geolocation.checked = (data.use_geolocation === 'true');
                    });

                    
                }

                document.getElementById('settingsForm').addEventListener('submit', function(e) {
                e.preventDefault();
                const form = e.target;
                const payload = {
                    session_name: form.session_name.value,
                    receiving_goal: form.receiving_goal.value,
                    default_latitude: form.default_latitude.value,
                    default_longitude: form.default_longitude.value,
                    use_geolocation: form.use_geolocation.checked ? 'true' : 'false'
                };

                fetch('/update_settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                })
                .then(res => res.json())
                .then(data => {
                    alert('Settings saved.');
                });
                });

                // Auto-load when switching to Settings tab
                document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => {
                    if (button.dataset.tab === 'settings-tab') {
                    loadSettings();
                    }
                });

            });

                //When clicking on trail point it sets default location in database
                function setAsDefaultLocation(lat, lon) {
                    fetch('/set_default_location', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ latitude: lat, longitude: lon })
                    })
                    .then(res => res.json())
                    .then(() => {
                        alert("Default location saved.");
                        window.db_center = [parseFloat(lat), parseFloat(lon)];

                            // Update marker position
                            if (window.defaultLocationMarker) {
                            window.defaultLocationMarker.setLatLng(window.db_center);
                            } else {
                            // If marker didn't exist, create it
                            window.defaultLocationMarker = L.marker(window.db_center, { icon: defaultIcon })
                                .addTo(window.map)
                                .bindTooltip("Default Location", { direction: 'bottom' });
                            }
                                // Update or create marker on mainMap
                            if (window.defaultLocationMarkerMain) {
                            window.defaultLocationMarkerMain.setLatLng(window.db_center);
                            } else {
                            window.defaultLocationMarkerMain = L.marker(window.db_center, {
                                icon: defaultIcon,
                                interactive: false
                            })
                            .addTo(window.mainMap)
                            .bindTooltip("Default Location", { direction: 'bottom' });
                            }
                            
                        // Optionally update savedCenter immediately
                        //savedCenter = [parseFloat(lat), parseFloat(lon)];
                    });
                    
                }

                
       
            //Functions to toggle layers on map
            document.getElementById('toggleMarkersLayer').addEventListener('change', function () {
                if (this.checked) {
                    markersLayerGroup.addTo(map);
                } else {
                    map.removeLayer(markersLayerGroup);
                }
            });

            document.getElementById('toggleGridLayer').addEventListener('change', function () {
                if (this.checked) {
                    gridLayerGroup.addTo(map);
                } else {
                    map.removeLayer(gridLayerGroup);
                }
            });

            document.getElementById('toggleTrailLayer').addEventListener('change', function () {
                if (this.checked) {
                    trailLayerGroup.addTo(map);
                } else {
                    map.removeLayer(trailLayerGroup);
                }
            });
            document.getElementById('toggleRssiLayer').addEventListener('change', function() {
            if (this.checked) {
                window.rssiLayerGroup.addTo(window.map);
            } else {
                window.map.removeLayer(window.rssiLayerGroup);
            }
            });






            //Function to create the map in map tab
            function initMap() {

            const savedCenter = JSON.parse(localStorage.getItem('defaultMapCenter') ||  '[32.0853, 34.7818]');
            const savedZoom = parseInt(localStorage.getItem('defaultMapZoom') || '10', 10);

            //Create map
            window.map = L.map('map', { attributionControl: false , maxZoom: MAX_ZOOM}).setView(savedCenter, savedZoom);
            L.control.attribution({ prefix: false }).addTo(map);


            //Add zIndex panes for enforcing order between layers
            map.createPane("gridPane");
            map.createPane("markerPane");
            map.createPane("trailPane");
            map.createPane("trailMarkerPane");
            map.createPane('rssiPane');



            //Order priorities
            map.getPane("trailMarkerPane").style.zIndex = 300;
            map.getPane("gridPane").style.zIndex = 400;
            map.getPane("markerPane").style.zIndex = 500;
            map.getPane("trailPane").style.zIndex = 600;
            map.getPane('rssiPane').style.zIndex = 200;
            
            //Add layers to map
            let gridLayerGroup;
            window.gridLayerGroup = L.layerGroup({ pane: 'gridPane' }).addTo(map);

            let rssiLayerGroup;    
            window.rssiLayerGroup = L.layerGroup({ pane: 'rssiPane' }).addTo(window.map);



            //let markersLayerGroup = L.layerGroup().addTo(map); original marker layers, instead of cluster
            let markersLayerGroup;
            window.markersLayerGroup = L.markerClusterGroup({
            iconCreateFunction: function (cluster) {
                // Get all markers in this cluster
                const markers = cluster.getAllChildMarkers();

                // Compute aggregated call result statistics
                let total = 0;
                let fails = 0;

                markers.forEach(marker => {
                const callResultStr = marker.options.callResult || '[]';
                let results = [];
                try {
                    results = JSON.parse(callResultStr);
                } catch(e) {}

                total += results.length;
                fails += results.filter(r => r.toLowerCase() !== "ok").length;
                });

                const failRatio = total > 0 ? (fails / total) : 0;

                // Determine color
                let c = 'marker-cluster-small';  // default class
                if (failRatio > 0.9) {
                c = 'marker-cluster-large';  // red (will style below)
                } else if (failRatio > 0.5) {
                c = 'marker-cluster-medium'; // yellow
                } else {
                c = 'marker-cluster-small';  // green
                }

                return new L.DivIcon({
                html: '<div><span>' + cluster.getChildCount() + '</span></div>',
                className: 'marker-cluster ' + c,
                iconSize: new L.Point(40, 40)
                });
            }
            }).addTo(map);  

            //Attach it to window so it will be a global variable accesible from outside
            let trailLayerGroup;
            window.trailLayerGroup = L.layerGroup({ pane: 'trailPane' }).addTo(map);

            var tilesource_layer = L.tileLayer('/static/tiles/{z}/{x}/{y}.png', {
                minZoom: 0,
                maxZoom: MAX_ZOOM,
                tms: false,
                errorTileUrl: '/static/fallback.png',
                attribution: 'Created by QGIS'
            }).addTo(map);
 
            map.doubleClickZoom.disable();//Disable zoom on double click

            //Double click function to set default zoom level
            map.on('dblclick', function (e) {
                const lat = e.latlng.lat.toFixed(5);
                const lng = e.latlng.lng.toFixed(5);
                const zoom = map.getZoom();

                if (confirm(`Set default view to:\nLat: ${lat}\nLng: ${lng}\nZoom: ${zoom}?`)) {
                    localStorage.setItem('defaultMapCenter', JSON.stringify([lat, lng]));
                    localStorage.setItem('defaultMapZoom', zoom);
                    alert("Default map view saved!");
                }
            });



            window.drawnItems = new L.FeatureGroup().addTo(map);

            window.drawControl = new L.Control.Draw({
                edit: {
                    featureGroup: drawnItems
                },
                draw: {
                    polygon: false,
                    rectangle: false,
                    circle: false,
                    circlemarker: false,
                    marker: false,
                    polyline: {
                        shapeOptions: {
                            color: 'orange',
                            weight: 4
                        }
                    }
                }
            });

            
            map.addControl(drawControl);

            // Disable touch auto-finish
            const polylineHandler = drawControl._toolbars.draw._modes.polyline.handler;
            polylineHandler._vertexChanged = function(latlng) {};

            map.on(L.Draw.Event.CREATED, function (e) {
                const layer = e.layer;
                drawnItems.addLayer(layer);

                const latlngs = layer.getLatLngs();

                if (confirm("Save this trail?")) {
                    // Send entire polyline to server
                    const trailData = latlngs.map(pt => ({
                        lat: pt.lat,
                        lon: pt.lng,
                        alt: 0  // You can extend for altitude if needed
                    }));

                    fetch('/save_trail', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(trailData)
                    })
                    .then(res => res.json())
                    .then(result => {
                        alert("Trail saved.");
                        drawnItems.clearLayers();
                        loadTrail();
                    });
                }
            });


            

            loadGridLayer();
            loadRssiLayer();
            loadMarkerLayer();
            loadTrail();    



        //================SEGMENT FOR MAIN PAGE MAP==================    
        // Create simple main screen map
        window.mainMap = L.map('mainMap', { attributionControl: false }).setView(savedCenter, savedZoom);
        L.control.attribution({ prefix: false }).addTo(mainMap);

        // Add only trailPane to this map
        mainMap.createPane("trailPane");
        mainMap.getPane("trailPane").style.zIndex = 500;

        mainMap.createPane("trailMarkerPane");
        mainMap.getPane("trailMarkerPane").style.zIndex = 400;

        L.tileLayer('/static/tiles/{z}/{x}/{y}.png', {
            minZoom: 0,
            maxZoom: MAX_ZOOM,
            tms: false,
            errorTileUrl: '/static/fallback.png'
        }).addTo(mainMap);

        //Add trail layer to map
        let trailLayerGroupMain;
        window.trailLayerGroupMain = L.layerGroup({ pane: 'trailPane' }).addTo(mainMap);



        //====================== Request phone location==============================
        let userMarker = null;

        navigator.geolocation.getCurrentPosition(function(position) {
            const userLat = position.coords.latitude;
            const userLng = position.coords.longitude;

            // Use icon instead   
            const icon = L.divIcon({
                html: '<i class="fas fa-location-arrow fa-2x" style="color: blue;"></i>',
                className: '',
                iconSize: [30, 30],
                iconAnchor: [15, 15]  // center the icon on the point
            });
            userMarker = L.marker([userLat, userLng], { icon: icon }).addTo(mainMap).bindTooltip("You are here");


            // Center the map initially
            mainMap.setView([userLat, userLng], 16);

            // Start watching for live updates
            navigator.geolocation.watchPosition(function(position) {
                const newLat = position.coords.latitude;
                const newLng = position.coords.longitude;

                 // Send to backend:
                fetch('/update_browser_location', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gps_location: `${userLat},${userLng}`
                    })
                }).then(res => {
                    if (!res.ok) {
                        console.error("Failed to send browser location");
                    }
                }).catch(err => {
                    console.error("Error sending browser location:", err);
                });

                console.log("Location updated:", newLat, newLng);
                showFlashMessage("Location updated:", newLat, newLng);

                // Move the existing marker
                userMarker.setLatLng([newLat, newLng]);
            }, function(error) {
                showFlashMessage("Unable to update location: " + error.message);
            }, {
                enableHighAccuracy: true,
                maximumAge: 10000,
                timeout: 5000
            });

        }, function(error) {
            showFlashMessage("Unable to get initial location: " + error.message);
        });

        mainMap.doubleClickZoom.disable();//Disable double click zoom on main map
        //======================================================================


        //===========Segment for drawing trail on main page map with leaflet draw=============
        const drawnItemsMain = new L.FeatureGroup().addTo(mainMap);
        const drawControlMain = new L.Control.Draw({
            edit: { featureGroup: drawnItemsMain },
            draw: drawControl.options.draw  // reuse same drawing config
        });
        mainMap.addControl(drawControlMain);

        // Disable touch auto-finish
        const mainMapPolylineHandler = drawControlMain._toolbars.draw._modes.polyline.handler;
        mainMapPolylineHandler._vertexChanged = function(latlng) {};

        mainMap.on(L.Draw.Event.CREATED, function (e) {
            const layer = e.layer;
            drawnItemsMain.addLayer(layer);

            const latlngs = layer.getLatLngs();

            if (confirm("Save this trail?")) {
                const trailData = latlngs.map(pt => ({
                    lat: pt.lat,
                    lon: pt.lng,
                    alt: 0
                }));

                fetch('/save_trail', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(trailData)
                })
                .then(res => res.json())
                .then(result => {
                    alert("Trail saved.");
                    drawnItemsMain.clearLayers();
                    loadMainMapTrail();
                });
            }
        });


            //Load trail in main map
            loadMainMapTrail();

            //==========Segment for adding default location icon===========
            // Create red pin icon (FontAwesome or default)
            const defaultIcon = L.divIcon({
            html: '<i class="fas fa-map-marker-alt fa-3x" style="color: red; text-shadow: 0 0 5px black;"></i>',
            className: '',
            iconSize: [24, 24],
            iconAnchor: [12, 24]
            });

            window.map.createPane("defaultMarkerPane");
            window.map.getPane("defaultMarkerPane").style.zIndex = 900;
            window.mainMap.createPane("defaultMarkerPane");
            window.mainMap.getPane("defaultMarkerPane").style.zIndex = 900;

            // Create the marker
            window.defaultLocationMarker = L.marker(window.db_center, { icon: defaultIcon , pane: "defaultMarkerPane", interactive: false})
            .addTo(window.map)
            .bindTooltip("Default Location", { direction: 'bottom' });

            window.defaultLocationMarkerMain = L.marker(window.db_center, { icon: defaultIcon , pane: "defaultMarkerPane", interactive: false})
            .addTo(window.mainMap)
            .bindTooltip("Default Location", { direction: 'bottom' });


            console.log("DB_CENTER=",window.db_center);


        }


            //Get default location from settings
        function initDefaultLocation() {
            fetch('/get_settings')
                .then(res => res.json())
                .then(settings => {
                let lat = parseFloat(settings.default_latitude || "32.1");
                let lon = parseFloat(settings.default_longitude || "34.8");
                window.db_center = [lat, lon];
                console.log("db_center initialized =", window.db_center);
                
                initMap();//Initialize the map

                //Initialize lock checkbox of map in main tab
                const lockState = localStorage.getItem('mapLock') === 'true';
                const checkbox = document.getElementById('lockMapCheckbox');
                checkbox.checked = lockState;
                setMapLockState(lockState);

                checkbox.addEventListener('change', function() {
                const isChecked = this.checked;
                setMapLockState(isChecked);
                localStorage.setItem('mapLock', isChecked);
                });

                });
        }  



        // Lock/unlock mainMap
        function setMapLockState(locked) {
        if (locked) {
            //window.mainMap._container.title = "Map is locked.";
            window.mainMap.dragging.disable();
            window.mainMap.scrollWheelZoom.disable();
            window.mainMap.doubleClickZoom.disable();
            window.mainMap.boxZoom.disable();
            window.mainMap.keyboard.disable();
            // Optionally disable touch zoom:
            if (window.mainMap.tap) window.mainMap.tap.disable();
        } else {
            //window.mainMap._container.title = "";
            window.mainMap.dragging.enable();
            window.mainMap.scrollWheelZoom.enable();
            window.mainMap.doubleClickZoom.disable();
            window.mainMap.boxZoom.enable();
            window.mainMap.keyboard.enable();
            if (window.mainMap.tap) window.mainMap.tap.enable();
        }
        }

        //Things that happen after page content is loaded
        document.addEventListener('DOMContentLoaded', function () {

            //Constant for received event
            const savedCount = localStorage.getItem('messageCounter');
            if (savedCount !== null) {
            messageCounter = parseInt(savedCount, 10);
            }
            updateMessageCounterDisplay();

            
            //Default map center and coordinate
            const savedCenter = JSON.parse(localStorage.getItem('defaultMapCenter') ||  '[32.0853, 34.7818]');
            const savedZoom = parseInt(localStorage.getItem('defaultMapZoom') || '10', 10)

            //Load settings on page load . This also initializes the map.
            initDefaultLocation();

            // Then set the lock state


            //On page load, load advanced/simple state
           const savedMode = localStorage.getItem('mode');
                if (savedMode === 'advanced') {
                    document.body.classList.add('advanced-mode');
                    document.getElementById('modeToggleButton').innerHTML = '<i class="fas fa-cogs"></i> Switch to Simple Mode';
                } else {
                    document.body.classList.remove('advanced-mode');
                    document.getElementById('modeToggleButton').innerHTML = '<i class="fas fa-cogs"></i> Switch to Advanced Mode';
            }   

            // On page load, always load latest modem state once
            fetch('/latest_json')
                .then(response => response.json())
                .then(data => {
                    if (data.senders && Object.keys(data.senders).length > 0) {
                        updateModemStatus(data);
                    }
                    updateStatusIndicators(data);  // <-- also update status indicators immediately
                });

            
            //Update if script is started or stopped
            updateStatusIndicators();
            updateMessageCounterDisplay();
            
            // Tab switching logic
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanels = document.querySelectorAll('.tab-panel');

            // Restore last tab from localStorage, or default to 'main-tab'
            const lastTabId = localStorage.getItem('activeTab') || 'main-tab';

            // Activate the stored/default tab
            function activateTab(tabId) {
                tabButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tab === tabId);
                });

                tabPanels.forEach(panel => {
                    panel.classList.toggle('active', panel.id === tabId);
                });
            }

            // Set initial tab
            activateTab(lastTabId);

            // Set click handlers
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.dataset.tab;
                    activateTab(tabId);
                    localStorage.setItem('activeTab', tabId); // Save to storage

                    // ✅ When activating map tab, force map resize.This is to fix error that maps act funny
                        if (tabId === 'map-tab') {
                        setTimeout(() => {
                            map.invalidateSize();
                        }, 100);  // slight delay ensures panel is visible
                    }
                    // For main tab too
                        if (tabId === 'main-tab') {
                        setTimeout(() => {
                            mainMap.invalidateSize();
                        }, 100);  // slight delay ensures panel is visible
                    }



                });
            });

               
            // Call fetchTableData immediately on load (This is for db table tab)
            fetchTableData();

            //Load settings from database
            loadSettings();

            // Start fetchData interval (This is for receiving modem data)
            fetchData(); // Call once immediately
            setInterval(fetchData, fetchDataInterval); // Call repeatedly every second

            
    });    
        //Interval for joining main table with call result table. Probably delete this
        //updateCallResult();
        //setInterval(updateCallResult, updateCallResultInterval);

    </script>
</body>
</html>
